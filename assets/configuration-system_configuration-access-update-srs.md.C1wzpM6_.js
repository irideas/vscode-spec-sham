import{_ as o,c as i,o as l,ae as a}from"./chunks/framework.B_lm770W.js";const g=JSON.parse('{"title":"VS Code Configuration 访问与变更子系统需求规格说明书 (SRS)","description":"","frontmatter":{},"headers":[],"relativePath":"configuration-system/configuration-access-update-srs.md","filePath":"configuration-system/configuration-access-update-srs.md","lastUpdated":1765282194000}'),c={name:"configuration-system/configuration-access-update-srs.md"};function t(n,e,r,u,d,s){return l(),i("div",null,[...e[0]||(e[0]=[a('<h1 id="vs-code-configuration-访问与变更子系统需求规格说明书-srs" tabindex="-1">VS Code Configuration 访问与变更子系统需求规格说明书 (SRS) <a class="header-anchor" href="#vs-code-configuration-访问与变更子系统需求规格说明书-srs" aria-label="Permalink to &quot;VS Code Configuration 访问与变更子系统需求规格说明书 (SRS)&quot;">​</a></h1><h2 id="_1-引言" tabindex="-1">1. 引言 <a class="header-anchor" href="#_1-引言" aria-label="Permalink to &quot;1. 引言&quot;">​</a></h2><h3 id="_1-1-目的" tabindex="-1">1.1 目的 <a class="header-anchor" href="#_1-1-目的" aria-label="Permalink to &quot;1.1 目的&quot;">​</a></h3><p>本 SRS 定义 <strong>VS Code Configuration 访问与变更子系统</strong> 的需求，该子系统负责：</p><ul><li>为 VS Code 核心模块与扩展提供统一的配置读取 API（如 <code>workspace.getConfiguration()</code>）；</li><li>封装配置写入逻辑（如 <code>WorkspaceConfiguration.update()</code> 以及内部写入服务）；</li><li>提供配置变更事件（如 <code>workspace.onDidChangeConfiguration</code>），驱动核心与扩展对配置变化作出反应；</li><li>将存储与分层子系统、声明子系统、Policy 层等复杂性隐藏在统一的编程访问面之后。</li></ul><h3 id="_1-2-系统范围" tabindex="-1">1.2 系统范围 <a class="header-anchor" href="#_1-2-系统范围" aria-label="Permalink to &quot;1.2 系统范围&quot;">​</a></h3><p>本子系统覆盖的内容包括：</p><ul><li><p>扩展 API 中与配置访问、变更、监听相关的行为与语义：</p><ul><li><code>vscode.workspace.getConfiguration(section?, scope?)</code>；</li><li><code>WorkspaceConfiguration.get/has/inspect/update</code>；</li><li><code>workspace.onDidChangeConfiguration</code> 与 <code>ConfigurationChangeEvent.affectsConfiguration(section, scope?)</code>。</li></ul></li><li><p>将上述 API 调用转换为对 Configuration 存储与分层子系统的读取、写入与模型变更请求；</p></li><li><p>基于统一的 ConfigurationScope（资源 URI、语言 ID、Workspace、WorkspaceFolder、Profile 等）定义配置访问上下文。</p></li></ul><p>本子系统<strong>不负责</strong>：</p><ul><li><code>settings.json</code> 等配置文件的物理路径定位、文件读写、文件监听、层级合并算法（由“存储与分层子系统”负责）；</li><li>Setting Schema 的声明、元数据（scope、default、enum 等）与校验规则定义（由“声明子系统”负责）；</li><li>Settings UI 的展示、交互与用户体验（由 Settings UI 子系统负责）；</li><li>Settings Sync 系统的同步协议、云端存储与冲突解决逻辑；</li><li>Enterprise Policy 系统的策略下发、管理与存储。</li></ul><h3 id="_1-3-目标读者" tabindex="-1">1.3 目标读者 <a class="header-anchor" href="#_1-3-目标读者" aria-label="Permalink to &quot;1.3 目标读者&quot;">​</a></h3><ul><li>VS Code 核心开发者与架构师；</li><li>Configuration Core 其他子系统实现者；</li><li>Settings Sync 系统与 Enterprise Policy 系统的实现者；</li><li>希望深入理解 VS Code 配置 API 行为的扩展开发者。</li></ul><hr><h2 id="_2-基线与引用" tabindex="-1">2. 基线与引用 <a class="header-anchor" href="#_2-基线与引用" aria-label="Permalink to &quot;2. 基线与引用&quot;">​</a></h2><ul><li>基线：默认 <code>engines.vscode</code> ≥ 1.80；Profile / Remote / Policy 层叠场景需考虑 scope 解析与拒绝写入行为。</li><li>官方参考：VS Code API (<code>workspace.getConfiguration</code>、<code>WorkspaceConfiguration</code>、<code>ConfigurationTarget</code>、<code>onDidChangeConfiguration</code>)、Settings UI、Settings Sync、Enterprise Policy 文档。</li><li>站内引用：/configuration-system/configuration-core-srs（体系级语义）、/configuration-system/configuration-storage-layering-srs（层与上下文模型）、/configuration-system/configuration-declaration-srs（schema 元数据）、/configuration-system/configuration-settings-ui-srs（UI 交互要求）。</li></ul><hr><h2 id="_3-在-configuration-core-与外部系统中的位置" tabindex="-1">3. 在 Configuration Core 与外部系统中的位置 <a class="header-anchor" href="#_3-在-configuration-core-与外部系统中的位置" aria-label="Permalink to &quot;3. 在 Configuration Core 与外部系统中的位置&quot;">​</a></h2><h3 id="_3-1-在-configuration-core-内的角色" tabindex="-1">3.1 在 Configuration Core 内的角色 <a class="header-anchor" href="#_3-1-在-configuration-core-内的角色" aria-label="Permalink to &quot;3.1 在 Configuration Core 内的角色&quot;">​</a></h3><p>访问与变更子系统是 Configuration Core 面向“代码世界”的统一门面，承担：</p><ul><li><p>对上：</p><ul><li>向扩展和核心模块暴露稳定的配置 API 与事件；</li><li>以 WorkspaceConfiguration 为承载形式提供配置的“合并视图”。</li></ul></li><li><p>对下：</p><ul><li>基于存储与分层子系统提供的 ConfigurationModel 完成读取；</li><li>通过统一写入管道将配置变更请求委派给存储与分层子系统；</li><li>借助声明子系统完成 setting 注册校验与类型检查。</li></ul></li></ul><p>该子系统不直接操作配置文件、也不自行维护层级合并逻辑，而是构建在统一 ConfigurationService 之上。</p><h3 id="_3-2-与-settings-sync-系统的关系" tabindex="-1">3.2 与 Settings Sync 系统的关系 <a class="header-anchor" href="#_3-2-与-settings-sync-系统的关系" aria-label="Permalink to &quot;3.2 与 Settings Sync 系统的关系&quot;">​</a></h3><ul><li><p>Settings Sync 系统是独立系统，不属于 Configuration 子系统的组成部分；</p></li><li><p>其作为“高权限调用者”使用本子系统提供的 API：</p><ul><li>使用读取 API 获取配置快照（或在必要时直接读取 User settings 文件）；</li><li>使用更新 API 将云端变更下发到本地配置。</li></ul></li></ul><p>本子系统不为 Settings Sync 系统暴露特殊 API，仅保证通用配置 API 满足其需求。</p><h3 id="_3-3-与-enterprise-policy-系统的关系" tabindex="-1">3.3 与 Enterprise Policy 系统的关系 <a class="header-anchor" href="#_3-3-与-enterprise-policy-系统的关系" aria-label="Permalink to &quot;3.3 与 Enterprise Policy 系统的关系&quot;">​</a></h3><ul><li>Enterprise Policy 系统也是独立系统，不属于 Configuration 子系统的组成部分；</li><li>Policy 系统通过 Configuration Core 内部服务向存储与分层子系统注入 Policy 层；</li><li>本子系统在读取时自动看到“包含 Policy 覆盖”的有效配置；</li><li>在写入时，如某 setting 被策略锁定，本子系统必须感知并拒绝对应更新请求，将失败信息反馈给调用方。</li></ul><hr><h2 id="_4-核心概念与术语" tabindex="-1">4. 核心概念与术语 <a class="header-anchor" href="#_4-核心概念与术语" aria-label="Permalink to &quot;4. 核心概念与术语&quot;">​</a></h2><h3 id="_4-1-workspaceconfiguration" tabindex="-1">4.1 WorkspaceConfiguration <a class="header-anchor" href="#_4-1-workspaceconfiguration" aria-label="Permalink to &quot;4.1 WorkspaceConfiguration&quot;">​</a></h3><ul><li><p>由 <code>workspace.getConfiguration(section?, scope?)</code> 返回；</p></li><li><p>代表在特定 section 与 scope 下的 <strong>已合并配置视图</strong>，包含：</p><ul><li>Default 层；</li><li>User 层（及 Profile / Remote 相关分片）；</li><li>Workspace 层；</li><li>WorkspaceFolder 层；</li><li>Language-specific 覆盖；</li><li>Policy 层覆盖。</li></ul></li></ul><p>提供的主要方法包括：</p><ul><li><code>get&lt;T&gt;(section, defaultValue?)</code>：获取最终生效值；</li><li><code>has(section)</code>：判断是否存在显式值；</li><li><code>inspect(section)</code>：获取各层值的详细信息；</li><li><code>update(section, value, configurationTarget?, overrideInLanguage?)</code>：请求写入配置。</li></ul><h3 id="_4-2-configurationscope" tabindex="-1">4.2 ConfigurationScope <a class="header-anchor" href="#_4-2-configurationscope" aria-label="Permalink to &quot;4.2 ConfigurationScope&quot;">​</a></h3><ul><li><p>描述配置访问上下文的抽象类型；</p></li><li><p>常见字段包括：</p><ul><li><code>resource</code>：URI，指向某文件或虚拟文档；</li><li><code>languageId</code>：如 <code>&quot;typescript&quot;</code>、<code>&quot;markdown&quot;</code> 等；</li><li><code>workspaceFolder</code>：当前资源所在的 Workspace Folder；</li><li><code>profileId</code>：当前 Profile 标识；</li><li>其他可能与 Remote 环境有关的标识。</li></ul></li></ul><p>ConfigurationScope 用于：</p><ul><li>决定 Workspace / WorkspaceFolder / Language-specific 等层的选择；</li><li>精确判断某配置变更是否影响特定资源或语言。</li></ul><h3 id="_4-3-configurationtarget" tabindex="-1">4.3 ConfigurationTarget <a class="header-anchor" href="#_4-3-configurationtarget" aria-label="Permalink to &quot;4.3 ConfigurationTarget&quot;">​</a></h3><ul><li><p>枚举类型，用于指定写入目标层：</p><ul><li><code>Global</code> / <code>User</code>：写入用户级设置；</li><li><code>Workspace</code>：写入当前 Workspace 级设置；</li><li><code>WorkspaceFolder</code>：写入当前 Workspace Folder 级设置。</li></ul></li></ul><p>在实际 API 中还支持布尔简写（如 <code>true</code> 表示 User，<code>false</code> 表示 Workspace），以及 <code>undefined</code> / <code>null</code> 触发默认推导规则。</p><h3 id="_4-4-configurationchangeevent-与-affectsconfiguration" tabindex="-1">4.4 ConfigurationChangeEvent 与 affectsConfiguration <a class="header-anchor" href="#_4-4-configurationchangeevent-与-affectsconfiguration" aria-label="Permalink to &quot;4.4 ConfigurationChangeEvent 与 affectsConfiguration&quot;">​</a></h3><ul><li><p><code>workspace.onDidChangeConfiguration</code> 事件的参数类型；</p></li><li><p>提供方法：</p><ul><li><code>affectsConfiguration(section: string, scope?: ConfigurationScope): boolean</code>；</li></ul></li></ul><p>用于在事件处理器中快速判断某变更是否影响扩展关心的配置，以避免对无关变更做昂贵处理。</p><hr><h2 id="_5-功能性需求-fr" tabindex="-1">5. 功能性需求（FR） <a class="header-anchor" href="#_5-功能性需求-fr" aria-label="Permalink to &quot;5. 功能性需求（FR）&quot;">​</a></h2><h3 id="_5-1-配置读取-api" tabindex="-1">5.1 配置读取 API <a class="header-anchor" href="#_5-1-配置读取-api" aria-label="Permalink to &quot;5.1 配置读取 API&quot;">​</a></h3><p><strong>FR-ACC-GET-001 <code>workspace.getConfiguration</code> 的行为</strong></p><ul><li><p>系统必须提供 <code>workspace.getConfiguration(section?: string, scope?: ConfigurationScope)</code>；</p></li><li><p>当 <code>section</code> 为非空字符串时：</p><ul><li>返回的 WorkspaceConfiguration 视图应以 <code>section</code> 为根前缀；</li><li>对 <code>get(&quot;foo&quot;)</code> 等调用，逻辑上对应完整 key 为 <code>&quot;section.foo&quot;</code>。</li></ul></li><li><p>当 <code>section</code> 为 <code>undefined</code> 或空字符串时：</p><ul><li>返回整个配置树的视图（常与 <code>languageId</code> scope 组合，用于语言特定设置）。</li></ul></li></ul><p><strong>FR-ACC-GET-002 已合并视图</strong></p><ul><li><p>通过 <code>workspace.getConfiguration</code> 获取的 WorkspaceConfiguration，在任何 <code>get</code> 调用中返回的值必须是：</p><ul><li>经过 Default → User → Workspace → WorkspaceFolder → Language-specific → Policy 的层级叠加后，在给定 scope 下的有效值；</li><li>调用方不需要也不应该自行重建合并逻辑。</li></ul></li></ul><p><strong>FR-ACC-GET-003 scope 敏感行为</strong></p><ul><li><p>若传入 <code>scope</code>：</p><ul><li>合并结果必须依据 scope 信息选择合适的 Workspace / WorkspaceFolder / Language-specific 层；</li><li>未传入 scope 时，应使用合理的默认上下文（如当前活动编辑器的资源与语言），但不得产生歧义或不一致行为。</li></ul></li></ul><p><strong>FR-ACC-GET-004 <code>WorkspaceConfiguration.get/has</code></strong></p><ul><li><p><code>get&lt;T&gt;(section)</code>：</p><ul><li>以 <code>section</code> 为点分 key 读取最终生效值；</li><li>若无任何层提供显式值，则返回 <code>undefined</code>。</li></ul></li><li><p><code>get&lt;T&gt;(section, defaultValue)</code>：</p><ul><li>若无显式值，则返回 <code>defaultValue</code>；</li><li>否则返回合并结果。</li></ul></li><li><p><code>has(section)</code>：</p><ul><li>只要某层对该 key 有显式赋值（包括语言特定块），即返回 <code>true</code>。</li></ul></li></ul><p><strong>FR-ACC-GET-005 <code>inspect</code> 多层信息暴露</strong></p><ul><li><p><code>inspect(section)</code> 必须返回一个包含各层值的结构对象，例如：</p><ul><li><code>defaultValue</code>、<code>globalValue</code>、<code>workspaceValue</code>、<code>workspaceFolderValue</code>；</li><li><code>defaultLanguageValue</code>、<code>globalLanguageValue</code>、<code>workspaceLanguageValue</code>、<code>workspaceFolderLanguageValue</code>；</li><li>以及可选的 <code>languageIds</code> 列表。</li></ul></li><li><p>若 <code>section</code> 不是叶子节点（如 <code>&quot;editor&quot;</code>），应返回 <code>undefined</code>。</p></li></ul><h3 id="_5-2-配置更新-api" tabindex="-1">5.2 配置更新 API <a class="header-anchor" href="#_5-2-配置更新-api" aria-label="Permalink to &quot;5.2 配置更新 API&quot;">​</a></h3><p><strong>FR-ACC-UPD-001 写入目标计算</strong></p><ul><li><p><code>WorkspaceConfiguration.update(section, value, configurationTarget?, overrideInLanguage?)</code> 必须遵守以下规则：</p><ul><li><p>当 <code>configurationTarget</code> 是枚举值时：</p><ul><li><code>ConfigurationTarget.Global</code> / <code>User</code>：写入 User 层；</li><li><code>ConfigurationTarget.Workspace</code>：写入当前 Workspace 层；</li><li><code>ConfigurationTarget.WorkspaceFolder</code>：写入当前 WorkspaceFolder 层。</li></ul></li><li><p>当 <code>configurationTarget</code> 是布尔值时：</p><ul><li><code>true</code> 等价于 User；</li><li><code>false</code> 等价于 Workspace。</li></ul></li><li><p>当 <code>configurationTarget</code> 为 <code>undefined</code> 或 <code>null</code> 时：</p><ul><li>若该 setting 为“资源特定”（依赖 resource scope），则默认写入当前 WorkspaceFolder 层；</li><li>否则默认写入当前 Workspace 层。</li></ul></li></ul></li><li><p>若当前环境无有效 workspace 而请求写入 Workspace / WorkspaceFolder，必须拒绝并返回错误。</p></li></ul><p><strong>FR-ACC-UPD-002 overrideInLanguage 行为</strong></p><ul><li><p>当 <code>overrideInLanguage === true</code> 时：</p><ul><li><p>如果 scope 中存在 <code>languageId</code>：</p><ul><li>更新应写入对应 <code>[languageId]</code> 语言特定块，而不是通用部分；</li></ul></li><li><p>若 scope 中缺少 <code>languageId</code>，应拒绝并返回错误，避免无法确定目标块。</p></li></ul></li><li><p>当 <code>overrideInLanguage === undefined</code> 时：</p><ul><li><p>若 schema 标记该 setting 支持语言覆盖，且 scope 中存在 <code>languageId</code>：</p><ul><li>默认写入语言特定块；</li></ul></li><li><p>否则写入通用部分。</p></li></ul></li></ul><p><strong>FR-ACC-UPD-003 删除设置语义</strong></p><ul><li><p>当 <code>value === undefined</code> 时：</p><ul><li>表示从指定层中删除该 setting 的显式值；</li><li>不应写入 <code>null</code> 或其他占位值；</li><li>删除后有效值应回退到更低优先级层（如 Workspace 删除后回退到 User/Default）。</li></ul></li></ul><p><strong>FR-ACC-UPD-004 写入前校验</strong></p><ul><li><p>在执行 update 之前，必须通过声明子系统进行校验：</p><ul><li>对应 setting 已注册；</li><li>value 类型符合 schema；</li><li>写入目标层符合 setting scope 要求（例如只能写 User 层的设置不能写 Workspace 层）。</li></ul></li><li><p>校验失败时，必须拒绝写入，并向调用方返回错误（Promise reject）。</p></li></ul><p><strong>FR-ACC-UPD-005 Policy 约束处理</strong></p><ul><li><p>若 setting 被 Policy 锁定或局部只读：</p><ul><li>对违反策略的写入请求必须被拒绝；</li><li>错误信息中应能区分“被策略锁定”和其他错误原因。</li></ul></li></ul><p><strong>FR-ACC-UPD-006 边界与错误条件</strong></p><ul><li><p>以下场景必须视为错误并拒绝操作：</p><ul><li>写入未注册的 setting；</li><li>在单文件模式或无 workspace 打开的场景下写入 Workspace / WorkspaceFolder；</li><li>需要 WorkspaceFolder scope 的 setting 却缺少 resource / folder 上下文；</li><li>将“窗口级配置”写入 WorkspaceFolder 目标；</li><li>其他违反 schema 或环境约束的情况。</li></ul></li></ul><h3 id="_5-3-配置变更事件" tabindex="-1">5.3 配置变更事件 <a class="header-anchor" href="#_5-3-配置变更事件" aria-label="Permalink to &quot;5.3 配置变更事件&quot;">​</a></h3><p><strong>FR-ACC-EVT-001 事件触发条件</strong></p><ul><li><p><code>workspace.onDidChangeConfiguration</code> 必须在以下情况下触发：</p><ul><li>用户通过 Settings UI 修改配置；</li><li>用户编辑并保存 <code>settings.json</code> 等配置文件；</li><li>扩展通过 update API 修改配置；</li><li>default/Policy 层发生改变导致有效配置值变化。</li></ul></li><li><p>实现可以将短时间内多次底层变更合并为一次事件，以避免事件风暴。</p></li></ul><p><strong>FR-ACC-EVT-002 affectsConfiguration 行为</strong></p><ul><li><p><code>ConfigurationChangeEvent.affectsConfiguration(section, scope?)</code> 必须满足：</p><ul><li>当且仅当给定 <code>section</code> 在本次变更中所依赖的层值发生变化时返回 <code>true</code>；</li><li>当提供 <code>scope</code> 时，仅在该 scope 下有效值发生变化才返回 <code>true</code>；</li><li>section 支持点分形式（如 <code>&quot;editor.fontSize&quot;</code>），也可用较粗粒度前缀（如 <code>&quot;editor&quot;</code>）。</li></ul></li><li><p>实现应保证 <code>affectsConfiguration</code> 调用在事件处理内部是轻量且无 I/O 的。</p></li></ul><h3 id="_5-4-与其他子系统的协作" tabindex="-1">5.4 与其他子系统的协作 <a class="header-anchor" href="#_5-4-与其他子系统的协作" aria-label="Permalink to &quot;5.4 与其他子系统的协作&quot;">​</a></h3><p><strong>FR-ACC-COOP-001 与存储与分层子系统</strong></p><ul><li>所有读取（get/has/inspect）行为必须通过 ConfigurationModel 完成；</li><li>所有写入（update）必须通过统一写入管道转交给存储与分层子系统；</li><li>访问与变更子系统不得直接访问或修改配置文件。</li></ul><p><strong>FR-ACC-COOP-002 与声明子系统</strong></p><ul><li><p>在 update 前必须通过声明子系统进行：</p><ul><li>setting 存在性校验；</li><li>类型与取值范围校验；</li><li>scope 校验（哪些层可写）。</li></ul></li></ul><p><strong>FR-ACC-COOP-003 与 Settings Sync 系统</strong></p><ul><li><p>当 User 层设置更新时：</p><ul><li>应以事件或回调的形式将变更通知 Settings Sync 系统；</li><li>同时保持 Sync 系统作为普通调用者使用通用 API 的模式，不引入专用 API。</li></ul></li></ul><p><strong>FR-ACC-COOP-004 与 Enterprise Policy 系统</strong></p><ul><li><p>Policy 系统通过内部适配器向存储层注入策略；</p></li><li><p>本子系统只需：</p><ul><li>在 get 时看到 Policy 覆盖后的结果；</li><li>在 update 时调用 Policy 检查接口决定是否拒绝操作。</li></ul></li></ul><hr><h2 id="_6-非功能性需求-nfr" tabindex="-1">6. 非功能性需求（NFR） <a class="header-anchor" href="#_6-非功能性需求-nfr" aria-label="Permalink to &quot;6. 非功能性需求（NFR）&quot;">​</a></h2><h3 id="_6-1-性能" tabindex="-1">6.1 性能 <a class="header-anchor" href="#_6-1-性能" aria-label="Permalink to &quot;6.1 性能&quot;">​</a></h3><p><strong>NFR-ACC-PERF-001 读取性能</strong></p><ul><li><code>workspace.getConfiguration</code> 与随后 <code>WorkspaceConfiguration.get</code> 调用必须被视作轻量操作；</li><li>在典型规模下，单次读取应为毫秒级开销，可在扩展激活和编辑循环中频繁调用。</li></ul><p><strong>NFR-ACC-PERF-002 写入性能</strong></p><ul><li><code>update</code> 应采用异步写入策略，不得长时间阻塞 UI 线程；</li><li>在批量修改配置时应有节流或合并策略，避免产生过多 I/O 与事件。</li></ul><h3 id="_6-2-一致性" tabindex="-1">6.2 一致性 <a class="header-anchor" href="#_6-2-一致性" aria-label="Permalink to &quot;6.2 一致性&quot;">​</a></h3><p><strong>NFR-ACC-CONS-001 视图一致性</strong></p><ul><li>在任意时刻，任一 WorkspaceConfiguration 实例通过 <code>get</code> 读取的值应与最新的 ConfigurationModel 一致；</li><li>在 update 的 Promise resolve 之前，不得触发变更事件，也不得对外暴露半写入状态。</li></ul><h3 id="_6-3-可测试性与可观测性" tabindex="-1">6.3 可测试性与可观测性 <a class="header-anchor" href="#_6-3-可测试性与可观测性" aria-label="Permalink to &quot;6.3 可测试性与可观测性&quot;">​</a></h3><p><strong>NFR-ACC-TEST-001 可测试性</strong></p><ul><li><p>访问与变更子系统的实现应支持对以下场景进行自动化测试：</p><ul><li>不同 ConfigurationTarget 的写入；</li><li>不同 scope（resource/language/workspaceFolder）的读取与写入；</li><li>多 WorkspaceFolder、语言特定覆盖的合并行为；</li><li>Policy 与 Schema 限制下的错误处理。</li></ul></li></ul><p><strong>NFR-ACC-OBS-001 可观测性</strong></p><ul><li>系统应支持在调试模式下输出配置变更事件的详细内容（包括受影响的 section 与 scope），以便调试复杂扩展；</li><li>可在日志或开发者工具中记录关键配置写入操作。</li></ul><hr><h2 id="_7-典型用例" tabindex="-1">7. 典型用例 <a class="header-anchor" href="#_7-典型用例" aria-label="Permalink to &quot;7. 典型用例&quot;">​</a></h2><h3 id="uc-acc-01-扩展读取自身设置并响应变更" tabindex="-1">UC-ACC-01 扩展读取自身设置并响应变更 <a class="header-anchor" href="#uc-acc-01-扩展读取自身设置并响应变更" aria-label="Permalink to &quot;UC-ACC-01 扩展读取自身设置并响应变更&quot;">​</a></h3><ul><li><p>场景：</p><ul><li>扩展声明 <code>myExtension.featureXEnabled</code>；</li><li>在激活时读取配置，并据此初始化行为；</li><li>订阅 <code>onDidChangeConfiguration</code> 以响应用户对该设置的修改。</li></ul></li><li><p>行为要求：</p><ul><li><code>workspace.getConfiguration(&#39;myExtension&#39;)</code> 返回合并视图；</li><li>当设置被修改时，事件触发且 <code>affectsConfiguration(&#39;myExtension.featureXEnabled&#39;)</code> 为 <code>true</code>；</li><li>扩展可在 handler 中根据新值调整行为。</li></ul></li></ul><h3 id="uc-acc-02-扩展写入用户级设置" tabindex="-1">UC-ACC-02 扩展写入用户级设置 <a class="header-anchor" href="#uc-acc-02-扩展写入用户级设置" aria-label="Permalink to &quot;UC-ACC-02 扩展写入用户级设置&quot;">​</a></h3><ul><li><p>场景：</p><ul><li>扩展在安装后希望为所有工作区设置某个默认路径到 User settings。</li></ul></li><li><p>行为要求：</p><ul><li>通过 <code>update(&#39;myExtension.path&#39;, value, ConfigurationTarget.Global)</code> 写入；</li><li>写入成功后，User 层 settings 文件被持久化更新；</li><li>所有工作区在后续读取中都能看到该值。</li></ul></li></ul><h3 id="uc-acc-03-写入语言特定设置" tabindex="-1">UC-ACC-03 写入语言特定设置 <a class="header-anchor" href="#uc-acc-03-写入语言特定设置" aria-label="Permalink to &quot;UC-ACC-03 写入语言特定设置&quot;">​</a></h3><ul><li><p>场景：</p><ul><li>扩展希望为 Markdown 文件设置特定的编辑器选项。</li></ul></li><li><p>行为要求：</p><ul><li>使用 <code>workspace.getConfiguration(&#39;&#39;, { languageId: &#39;markdown&#39;, resource: uri })</code> 获取配置对象；</li><li>调用 <code>update(&#39;editor.fontSize&#39;, 14, ConfigurationTarget.Workspace, true)</code>；</li><li>更新被写入 Workspace 级 <code>[markdown]</code> 块，仅对 Markdown 文档生效。</li></ul></li></ul><h3 id="uc-acc-04-使用-inspect-诊断复杂叠加" tabindex="-1">UC-ACC-04 使用 inspect 诊断复杂叠加 <a class="header-anchor" href="#uc-acc-04-使用-inspect-诊断复杂叠加" aria-label="Permalink to &quot;UC-ACC-04 使用 inspect 诊断复杂叠加&quot;">​</a></h3><ul><li><p>场景：</p><ul><li>扩展需要诊断 <code>editor.tabSize</code> 的来源层。</li></ul></li><li><p>行为要求：</p><ul><li>调用 <code>inspect(&#39;editor.tabSize&#39;)</code> 获得 default/global/workspace/workspaceFolder 及对应 language-specific 值；</li><li>扩展可将此信息输出到日志或调试 UI，帮助开发者理解当前配置。</li></ul></li></ul><hr>',108)])])}const f=o(c,[["render",t]]);export{g as __pageData,f as default};
